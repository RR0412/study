Индекс — отдельная отсортированная структура, ускоряет поиск по столбцу.
Без индекса → Full Table Scan (читается вся таблица с диска) → медленно.
С индексом → Index Seek: читается только индекс + нужные строки → быстро (в десятки-сотни раз).
Основной выигрыш: вместо O(n) получаем O(log n) благодаря бинарному поиску.
Создаём индекс на столбцы, которые часто используются в WHERE, JOIN, ORDER BY, GROUP BY.

Практическое правило
Если запрос по этому полю работает медленно → делай индекс.
Если не уверен → смотри план выполнения (EXPLAIN) и ищи «Seq Scan» → нужен индекс.

1. Создаём индекс
SQLCREATE INDEX idx_orders_customer ON orders(customer_id);
CREATE UNIQUE INDEX idx_products_sku ON products(sku);
CREATE INDEX idx_orders_date_cust ON orders(order_date, customer_id); -- составной
Когда создавать

Столбец часто в WHERE, JOIN, ORDER BY, GROUP BY
Особенно: внешние ключи (customer_id, product_id, order_id и т.д.)
UNIQUE — когда нужно гарантировать уникальность (email, sku, логин)

2. Кластерный vs некластерный

Кластерный — только один на таблицу, физически сортирует строки
PostgreSQL: делается через CLUSTER или при PRIMARY KEY по умолчаниюSQLALTER TABLE orders ADD PRIMARY KEY (order_id); -- обычно кластерный
Некластерный — обычный CREATE INDEX (все остальные)

3. Порядок столбцов в составном индексе — критично
Правильно:
SQLCREATE INDEX ON orders(customer_id, order_date); -- можно и по customer_id, и по customer_id + order_date
Неправильно (не будет использоваться эффективно):
SQL-- по order_date отдельно индекс почти бесполезен, если ищешь только по дате
4. Плотный vs разреженный

Все обычные индексы в PostgreSQL — плотные (на каждую строку)
Разреженный = только кластерный (автоматически)

5. Минусы индексов (когда НЕ создавать)

Таблица маленькая (< 10–20к строк) — часто не нужен
Очень частые INSERT/UPDATE/DELETE — каждый индекс тормозит
Столбец с низкой селективностью (много одинаковых значений: пол, статус = 'active')

6. Как проверить, нужен ли индекс
SQLEXPLAIN ANALYZE SELECT * FROM orders WHERE customer_id = 123;
-- Ищешь Seq Scan + большое время → нужен индекс
-- Видишь Index Scan / Index Only Scan → всё ок
Практические правила, которые реально спасают

Всегда индексируй внешние ключи
В составном индексе ставь первым столбец с наибольшей селективностью
Не лепи индексы на всё подряд — 3–7 индексов на большую таблицу обычно хватает
После создания проверяй EXPLAIN — использует ли индекс