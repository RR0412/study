ER (Entity-Relationship) — графическая модель для проектирования БД  
Главное: переводим «человеческие» описания бизнеса → точную схему таблиц

Зачем нужна
- Быстро договориться с заказчиком/преподом, что именно храним
- Понять сущности и связи до написания CREATE TABLE
- Структура данных меняется редко → правильно спроектированная ER-модель живёт годами

Стадии развития модели (запомнить порядок)
1. Описание от клиента (слова)
2. ER-диаграмма (сущности + связи)
3. Табличная модель (таблицы, PK, FK)
4. Реальные таблицы в БД

Преимущества ER-модели (коротко, для зачёта)
- Графика понятнее текста
- Легко править на ранних стадиях
- Все видят одно и то же
- Документация сразу готова


Что такое сущность
Набор объектов одного типа, про которые храним одинаковые данные  
Примеры: КЛИЕНТ, ТОВАР, ПОСТАВКА, СТУДЕНТ

Как рисуется
┌─────────────────┐
│   КЛИЕНТ        │  ← прямоугольник со скруглёнными углами
└─────────────────┘  ← имя всегда ЗАГЛАВНЫМИ буквами

Подсущность (sub-entity)
Когда часть записей имеет свои дополнительные поля  
Примеры:
СТУДЕНТ
└── БАСКЕТБОЛИСТ (доп. поля: рост, позиция)
    └── ЧЛЕН СБОРНОЙ (ещё доп. поля)

Как реализуется в таблицах (два варианта — оба правильные)
1. Отдельная таблица + связь 1-к-1
   students (id, name, …)
   basketball_players (student_id PK/FK → students, height, position)

2. Все поля в одной таблице (если подсущность редко используется)
   students (id, name, height NULL, position NULL, …)
   → поля NULL у обычных студентов

# 3. Атрибуты и связи — нотация Баркера

### Атрибуты
┌─────────────────────┐
│     КЛИЕНТ          │
├─────────────────────┤
│ # client_id         │  ← UID (первичный ключ)
│ * surname           │  ← обязательный (NOT NULL)
│ * name              │
│ ° phone             │  ← необязательный (может быть NULL)
│ (# email)           │  ← альтернативный уникальный ключ
└─────────────────────┘

Символы (запомнить навсегда)
#  → входит в первичный UID
(#) → альтернативный уникальный идентификатор
*  → обязательный атрибут
°  → необязательный атрибут

### Связи (Relationships)

Как читать (самое важное правило)
«Каждая … {должна быть / может быть} … {один и только один / один или более} …»

Символы линий
───────   сплошная    = должен быть (обязательно)
- - - -   пунктир     = может быть (опционально)
────┐     одинарная   = один и только один
────┼    куриная лапка = один или более (много)

Пример из рисунка выше
Каждый КЛИЕНТ должен быть прикреплён к одному и только одному СЛУЖАЩЕМУ
Каждый СЛУЖАЩИЙ может быть торговым представителем одного или более КЛИЕНТОВ

### Рекурсивная связь
┌─────────────────┐         ┌─────────────────┐
│   СОТРУДНИК     │◄────────│   СОТРУДНИК     │
│ # id            │   руководитель boss_id (FK → id)│
│ * name          │────────┘                 │
└─────────────────┘

### UID через связь (чёрточка над линией)
Если сущность идентифицируется только через другую:
┌──────────────┐      ┌─────────────────┐
│   ЗАКАЗ      │──────│     КЛИЕНТ      │
│ # order_no   │      │ # client_id     │
│ # client_id  │◄─────┤                 │  ← чёрточка = FK входит в PK
└──────────────┘ 1:1  └─────────────────┘
→ в таблице orders будет составной PK (order_no, client_id)

# 4. ER → Таблицы (правила перевода — запомнить навсегда)

Основные 4 шага
1. Сущность → таблица
2. Атрибуты → колонки
3. UID (#) → PK
4. Связи → FK

### Символы в «бланке экземпляра таблицы»
PK   – первичный ключ
FK   – внешний ключ  
FK1, FK2 – несколько внешних ключей
NN   – NOT NULL
U    – уникальное поле (UNIQUE)
U1   – часть составного уникального индекса

### Точный перевод нотации Баркера → таблица
ER-символ       → в таблице
# id            → PK + NN + U
* name          → NN
° phone         → может быть NULL
(# email)       → U (альтернативный уникальный ключ)

### Связи → как ставить FK
1:М (один-ко-многим) → FK ставим на стороне «много»
   КЛИЕНТ 1 ─────── М ЗАКАЗЫ  → в таблице orders: client_id FK → clients.id

М:1 (много-к-одному) → то же самое, просто читаем наоборот

1:1 (один-к-одному) → FK можно ставить в любой таблице, но обычно в той, где обязательная сторона

М:M (многие-ко-многим) → отдельная таблица с двумя FK
   СТУДЕНТ М ─────── М КУРСЫ → таблица student_courses (student_id FK, course_id FK)

Рекурсия → FK на саму себя
   СОТРУДНИК
   └─ boss_id FK → employees.id

UID через связь (чёрточка над линией) → FK входит в составной PK
   ЗАКАЗ #order_no + #client_id FK → PK(order_no, client_id)

### Что ещё пишут в бланке таблицы (для красоты)
- Типы данных (varchar(50), decimal(10,2), date и т.д.)
- Примеры значений в строке снизу
- Индексы (обычно по FK и по полям из WHERE)
Пример бланка (как любят видеть на зачёте)
textТаблица: orders
┌─────────────────┬────────────┬─────────┬─────────────┐
│ Имя колонки     │ Тип        │ Ключи   │ Пример      │
├─────────────────┼────────────┼─────────┼─────────────┤
│ order_id        │ serial     │ PK NN U │ 1001        │
│ order_date      │ date       │ NN      │ 2025-03-15  │
│ client_id       │ int        │ FK NN   │ 57          │ ← FK → clients.id
│ total_sum       │ decimal    │         │ 15420.00    │
└─────────────────┴────────────┴─────────┴─────────────┘

# 5. Рекурсивная связь (само-соединяющаяся таблица)

Как выглядит в ER-диаграмме
┌─────────────────┐
│   СОТРУДНИК     │◄──────────────────────┐
│ # id            │                      │
│ * surname       │      работает под    │
│ * name          │    руководством      │
│ boss_id         │──────────────────────┘
└─────────────────┘
(стрелка возвращается в ту же сущность)

Как выглядит в таблице
employees
┌────────────┬──────────┐
│ id         │ PK       │
│ surname    │ NN       │
│ name       │ NN       │
│ boss_id    │ FK → employees.id   ← вот и вся рекурсия!
└────────────┴──────────┘
- У генерального директора boss_id = NULL

Как писать запросы (главный лайфхак — псевдонимы!)
-- Все подчинённые Иванова и Петрова
SELECT 
    b.surname   AS начальник,
    s.surname   AS подчинённый,
    s.position
FROM employees AS b
JOIN employees AS s ON b.id = s.boss_id
WHERE b.surname IN ('Иванов', 'Петров');

-- Все уровни подчинения (рекурсивный CTE в PostgreSQL)
WITH RECURSIVE subordinates AS (
    SELECT id, surname, boss_id, 1 AS level
    FROM employees WHERE surname = 'Иванов'
    UNION ALL
    SELECT e.id, e.surname, e.boss_id, s.level + 1
    FROM employees e
    JOIN subordinates s ON e.boss_id = s.id
)
SELECT * FROM subordinates;


# 6. GROUP BY + HAVING 

GROUP BY нужен, когда хочешь посчитать агрегаты НЕ по всей таблице, а отдельно по каждой категории/группе.

Порядок выполнения запроса 
1. FROM / JOIN
2. WHERE          ← фильтр отдельных строк
3. GROUP BY       ← группируем оставшиеся строки
4. HAVING         ← фильтр уже по группам (по агрегатам!)
5. SELECT
6. ORDER BY

Как пишем (в коде): SELECT → FROM → WHERE → GROUP BY → HAVING → ORDER BY
Как выполняется (внутри движка): FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY

Главное правило
- В SELECT можно только:
  • поля из GROUP BY
  • агрегатные функции (SUM, COUNT, AVG, MIN, MAX)
- Иначе ошибка (или надо добавить поле в GROUP BY)

Агрегатные функции
COUNT(*)      – количество строк
COUNT(поле)   – количество НЕ NULL
SUM(), AVG(), MIN(), MAX()

1. Сумма/количество по поставщикам
SELECT 
    s.supplier,
    SUM(a.qty * a.price)      AS total_sum,
    SUM(a.qty)                AS total_qty,
    COUNT(*)                  AS deliveries_cnt
FROM actions a
JOIN suppliers s ON a.supplier_id = s.id
GROUP BY s.supplier, s.id          -- обязательно!
ORDER BY total_sum DESC;

1. Только те, у кого сумма > 100 000
… GROUP BY …
HAVING SUM(a.qty * a.price) > 100000   -- НЕ WHERE!

1. Топ-3 поставщиков по сумме (PostgreSQL)
SELECT …
FROM …
GROUP BY …
ORDER BY SUM(a.qty*a.price) DESC
LIMIT 3;

WHERE vs HAVING 
WHERE   → фильтрует ДО группировки (по отдельным строкам)
HAVING  → фильтрует ПОСЛЕ группировки (по SUM/COUNT и т.д.)

Пример:
-- только поставки товара Monitor DD27 и сумма > 50 000
WHERE a.product_id = 14
GROUP BY supplier_id
HAVING SUM(qty*price) > 50000

Блок 8 — HAVING (финальный кусок)
 HAVING — фильтр ПОСЛЕ GROUP BY

Где ставится: всегда ПОСЛЕ GROUP BY (а не вместо WHERE!)

Зачем нужен:
WHERE не может фильтровать по SUM/COUNT/AVG — они ещё не посчитаны.
HAVING может — потому что агрегаты уже готовы.

Пример из урока 
-- Поставщики, у которых общая сумма поставок > 115 000
SELECT 
    s.supplier,
    SUM(a.qty * a.price) AS total
FROM actions a
JOIN suppliers s ON a.supplier_id = s.id
GROUP BY s.supplier
HAVING SUM(a.qty * a.price) > 115000;

Комбинированный пример 
-- Товары 2017 года, проданные больше чем на 200 000 руб.
SELECT 
    p.product,
    SUM(a.qty * a.price) AS total
FROM actions a
JOIN products p ON a.product_id = p.id
WHERE EXTRACT(YEAR FROM a.action_date) = 2017    -- строки
GROUP BY p.product
HAVING SUM(a.qty * a.price) > 200000             -- группы
ORDER BY total DESC;